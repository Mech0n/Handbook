# Chapter 3

#### R0

***rdt***比较：

Rdt1.0:

1. 假设底层信道完全可靠
2. 只有下图一个状态。

![rdt 1.0](https://i.loli.net/2019/11/21/OgcMvT9VoyFj5Sm.png)

Rdt2.0（停等协议）:

1. 假定所有发送分组按发送顺序到达，但是分组中bit可能受损。
2. 加入**自动重传请求**，使用 差错检测；反馈：肯定确认(ACK)和否定确认(NAK)；重传。

![rdt 2.0](https://i.loli.net/2019/11/21/LhzIY2yETwOXsBC.png)

Rdt2.1

1. 假定所有发送分组按发送顺序到达，但是分组中bit可能受损，ACK或NAK包也会受损。

2. 添加**冗余分组**，在发送方不确定接收到的是ACK还是NAK的时候，重传上次分组。

3. 为发送的分组编号。（此时ACK/NAK不必指定其所属分组编号，因为，假定信道不丢失分组）

   ![rdt2.1 sender](https://i.loli.net/2019/11/21/VSATblCOgcjIDLw.png)

<img src="https://i.loli.net/2019/11/21/T3XchxLZvYJs976.png" alt="rdt 2.1 receiver" style="zoom:80%;" />

Rdt 2.2

1. Rdt2.2 与 Rdt 2.1 的差别在于，Rdt2.2不发送NAK，取而代之的是包含上个分组序号的ACK（冗余ACK）

   ![rdt2.2 sender](https://i.loli.net/2019/11/21/a6pQGY4BARTl23s.png)

   ![rdt2.2 receiver](https://i.loli.net/2019/11/21/3Bn9HuowON1l5Fa.png)

Rdt3.0（比特交替协议）

1. 信道中分组可能丢失

2. 发送方加入定时器，如果丢包准备重传。

3. 接收方动作与rdt2.2相同

   ![rdt3.0 sender](https://i.loli.net/2019/11/21/w5ki98JOnGb6qjZ.png)

#### R1

1. 将此协议称为简单传输协议（STP）。 在发送方，STP从发送过程中接收不超过1196字节的数据块，一个目标主机地址和一个目标端口号。 STP在每个块上添加一个四字节的标头，并将目标进程的端口号放在此标头中。 然后，STP将目标主机地址和生成的段提供给网络层。 网络层将网段传送到目标主机上的STP。 然后，STP检查段中的端口号，从段中提取数据，然后将数据传递给由端口号标识的进程。
2. 该段现在具有两个标题字段：源端口字段和目标端口字段。 在发送方，STP接受不超过1192字节的数据块，目标主机地址，源端口号和目标端口号。 STP创建一个包含应用程序数据，源端口号和目标端口号的段。 然后，它将网段和目标主机地址提供给网络层。 接收到该段后，接收主机上的STP会为应用程序进程提供应用程序数据和源端口号。
3. 不，传输层不必在网络核心中做任何事情； 传输层“存在”于端系统中。

#### R2

1. 家庭成员要寄信，家庭成员必须给某个代表人自己的信，告诉代表人目的地地址和收件人的姓名。 代表人清楚地在信的顶部写下了收件人的名字。（神奇的设定。。。） 然后，代表将信放入信封中，然后在信封上写上目标房屋的地址。 然后，代表将这封信交给地球的邮件服务。 在接收方，代表从邮件服务接收信件，将信件从信封中取出，并记下写在信件顶部的收件人姓名。 然后，代表用这个名字将信件交给家庭成员。
2. 不必。只需要检查目的地址并将信封交付给目的地的代表人。

#### R3

源端口号：y

目的端口号：x

#### R4

应用程序开发人员可能不希望其应用程序受到TCP的拥塞控制，这可能会在拥塞时限制应用程序的发送速率。 IP电话和IP视频会议应用程序的设计人员通常选择通过UDP运行其应用程序，因为他们希望避免TCP的拥塞控制。 另外，某些应用程序不需要TCP提供的可靠数据传输。

1. 无需建立连接，不受拥塞控制，减少传输延时。
2. 不需要保证可靠数据连接。
3. 分组首部开销少。UDP首部只有8字节。

#### R5

**由于大多数防火墙都配置为阻止UDP流量，因此使用TCP进行视频和语音流量将使流量通过防火墙。**

#### R6

可以。 应用程序开发人员可以将可靠的数据传输放入应用层协议中。 但是，这将需要大量的工作和调试。

#### R7

是的，两个段将被指向同一个套接字。对于每个接收到的报文段，在套接字接口上，操作系统将向进程提供IP地址，以确定各个段的起源。

#### R8

对于每个持久连接，Web服务器都会创建一个单独的“连接套接字”。 每个连接套接字都用四元组标识：（源IP地址，源端口号，目标IP地址，目标端口号）。 当主机C接收到IP数据报时，它会检查数据报/段中的这四个字段，以确定应将TCP段的有效负载传递到哪个套接字。 因此，来自A和B的请求将通过不同的套接字。 这两个套接字的标识符的目标端口号均为80。 但是，这些套接字的标识符对于源IP地址具有不同的值。与UDP不同，当传输层将TCP段的有效负载传递给应用程序进程时，它不指定源IP地址，因为它是由套接字标识符隐式指定的。

#### R9

接收者需要序号来确定到达的数据包是否包含新数据还是重传。

#### R10

处理信道分组丢失。 如果在该数据包的计时器持续时间内未收到该数据包的ACK，则假定该数据包（或其ACK或NAK）丢失。 因此，该分组被重新发送。

#### R11

在协议rdt 3.0中仍然需要一个计时器。 

如果知道往返时间，那么唯一的好处就是，与实际情况相比，发送方可以肯定地知道该数据包或该数据包的ACK（或NAK）已经丢失。

但是，要检测丢失，对于每个数据包，在发送方仍然需要一个持续时间恒定的计时器。

#### R14

- a) false 
- b) false 
- c) true 
- d) false 
- e) true 
- f) false 
- g) false

#### R15

1. 20 bytes
2. ) ack number = 90

#### R16

3段。

第一段:seq = 43, ack =80;

第二段:seq = 80, ack = 44;

第三段;seq = 44, ack = 81。

#### R17

$R/2$Bps

#### R18

False。

将其设置为拥塞窗口当前值的一半。

#### R19

![](https://i.loli.net/2019/11/21/IJEXpsl2uKnHboV.png)

![](https://i.loli.net/2019/11/21/Ix4cYf8pClQX1eS.png)

#### P1

![](https://i.loli.net/2019/11/21/UPLmoei8C6NpfsO.png)

e) 可能相同

f)不会相同。

#### P10

在这里，我们添加一个计时器，该计时器的值大于已知的往返传播延迟。 我们将超时事件添加到“等待ACK或NAK 0”和“等待ACK或NAK 1”状态。 如果发生超时事件，将重新发送最近发送的数据包。 

- 假设超时是由丢失的数据包（即发送方到接收方通道上的数据包）引起的。 在这种情况下，接收方从未收到过先前的传输，并且从接收方的角度来看，如果接收到超时重传，则它看起来与接收原始传输完全相同。
- 现在假设ACK丢失了。 接收者最终将在超时时重新发送数据包。 但是重传与如果ACK乱码的情况完全相同。 因此，发送方的反应是一样的，但相当于接收到一个错误的ACK。 rdt 2.1协议已经可以处理乱码ACK的情况。

#### P22

1. 在这里，我们的窗口大小为N = 4。 假设接收方已收到数据包k-1，并已确认该数据包和所有其他先前的数据包。 如果发送方已收到所有这些ACK，则发件人的窗口为[k，k + N-1]。 接下来，假设在发送方没有收到任何ACK。 在第二种情况下，发件人的窗口包含k-1和N个数据包，直到k-1。 因此，发送者的窗口为[k-N，k-1]。 通过这些参数，发送方窗口的大小为4，开始于[k-N，k]范围内的某处。

2. 如果接收方正在等待数据包k，则它已接收（并已确认）数据包k-1和N-1数据包。 如果发送方尚未收到这N个ACK，则可能仍在传播[k-N，k-1]的ACK。由于发送方已发送数据包[k-N，k-1]，因此发送方一定已经收到了

   k-N-1的ACK。 一旦接收方发送了针对k-N-1的ACK，它将永远不会发送小于k-N-1的ACK。 因此，信道上ACK值的范围可以从k-N-1到k-1。

#### P24

1. 真。 假设发送方的窗口大小为3，并以$ t_1 $发送数据包1、2、3。 接收方在$ t_1 $（$ t_1 $> $ t_0 $）确认1，2，3。在$ t_2 $（$ t_2 $ > $ t_1 $），发送方超时并重新发送1，2，3。在$ t_3 $接收方接收重复的数据，并重新确认1、2、3。在$ t_4 $，发送方接收到接收方在$ t_1 $发送的ACK，并将其窗口前进到4、5、6。在$ t_5 $，发送方 接收接收方在$ t_ {2} $发送的ACK 1、2、3。 这些ACK在其窗口之外。
2. 真。 基本上与1中相同。
3. 是的
4. 真。 请注意，窗口大小为1时，SR，GBN和交替位协议在功能上等效。 窗口大小为1排除了乱序数据包（在窗口内）的可能性。 累积ACK是在这种情况下，只是一个普通的ACK，因为它只能参照窗口内的单个数据包。

#### P27

a) 在从主机A到主机B的第二段中，序列号是207，源端口号是302，目的端口号是80。

b) 如果第一个段在第二个段之前到达，则在第一个到达段的确认中，确认号为207，源端口号为80，目的端口号为302。

c) 如果第二个段在第一个段之前到达，则在第一个到达段的确认中，确认号为127，表示它仍在等待字节127及以后。

d) ![](https://i.loli.net/2019/11/21/zJnMutOgR2ApZVW.png)