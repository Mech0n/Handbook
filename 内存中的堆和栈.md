---
title: 学习笔记--内存中的堆和栈
date: 2019-12-17 10:54:32
tags: pwn
---

# 学习笔记——内存中的堆和栈杂记

### 0x0 参考

[内存中的堆和栈到底是什么](https://www.jianshu.com/p/52b5a1879aa1)

常用到的代码段：

```c
int a = 0; //全局初始化区
char *p1; //全局未初始化区
main()
{ 
    int b; //栈
    char s[] = "abc"; //栈
    char *p2; //栈
    char *p3 = "123456"; //123456\0在常量区，p3在栈上
    static int c =0； //全局（静态）初始化区
    p1 = (char *)malloc(10); //堆
    p2 = (char *)malloc(20);  //堆
}
```

常用到的图：

![常用图](https://i.loli.net/2019/12/17/k76wDXFn3mSpOJt.jpg)

### 1x1汇编中的三个段

在一个汇编程序中，常常把一个用户空间程序按习惯分为三个段：**.data段，.bss段，.text段。**

#### .data 段

.data段中包含的是**已经初始化的数据**，这些数据在运行的时候就拥有自己的值，换句话说就是，这些数据已经是程序的一部分，被加载到内存中。

如这些语句：

```c
int a = 0; //全局初始化区
main()
{ 
    static int c =0； //全局（静态）初始化区
}
```

#### .bss 段

.bss 段相当于一个缓冲区，怎么理解呢。就是说，代码段中不尽然是已经初始化的数据，仍会有一些没有被初始化的变量，这些变量（或者说数据项），被存放在.bss段中。

>分别定义**.data段**与**.bss段**中的数据，它们一个重要的区别就是：**.data段**中的数据会添加到可执行文件的大小上，而**.bss段**中的则不会。即便你给**.bss段**定义一个1M字节的缓冲区，其最终可执行文件大小也几乎不变(除了大约50个字节用于描述外)。

程序在加载时会为没有初值的数据项分配空间。

另外，未经过初始化的全局或者静态数据项的变量，属于**.bss段**。

#### .text段

组成程序的机器指令存放在.text段中。

一般情况下，在**.text段**中不进行数据项的定义。

.text段包含名为标号(label)的符号，这些符号用于标识跳转和调用程序代码位置。

### 0x2 内存中的堆和栈

![](https://i.loli.net/2019/12/17/NHyAIsUfW8Joenp.png)

### 0x3 linux调用约定

参考：Winx64调用[[原创]常见函数调用约定(x86、x64、arm、arm64)](https://bbs.pediy.com/thread-224583.htm)

#### System V AMD64 ABI

此约定主要在Solaris，GNU/Linux，FreeBSD和其他非微软OS上使用。

- 头六个整型参数放在寄存器RDI, RSI, RDX, RCX, R8和R9上；

- 同时XMM0到XMM7用来放置浮点变元。

- 对于系统调用，R10用来替代RCX。

- 同微软x64约定一样，其他额外的参数推入栈，
- 返回值保存在RAX中。 
- 与微软不同的是，不需要提供影子空间。
- 在函数入口，返回值与栈上第七个整型参数相邻。

#### thiscall

在调用[C++](https://zh.wikipedia.org/wiki/C%2B%2B)非静态成员函数时使用此约定。基于所使用的编译器和函数是否使用可变参数，有两个主流版本的thiscall。 对于GCC编译器，thiscall几乎与cdecl等同：调用者清理堆栈，参数从右到左传递。差别在于this指针，thiscall会在最后把this指针推入栈中，即相当于在函数原型中是隐式的左数第一个参数。

在[微软](https://zh.wikipedia.org/wiki/微软)[Visual C++](https://zh.wikipedia.org/wiki/Visual_C%2B%2B)[编译器](https://zh.wikipedia.org/wiki/编译器)中，this指针通过ECX寄存器传递，其余同cdecl约定。当函数使用可变参数，此时调用者负责清理堆栈(参考cdecl)。thiscall约定只在微软Visual C++ 2005及其之后的版本被显式指定。其他编译器中，thiscall并不是一个关键字(反汇编器如IDA使用__thiscall)。

### ret leave call

#### ret

```assembly
pop eip
```

#### leave

```assembly
IF StackAddressSize = 32
    THEN
        ESP ← EBP;
    ELSE IF StackAddressSize = 64
        THEN RSP ← RBP; FI;
    ELSE IF StackAddressSize = 16
        THEN SP ← BP; FI;
FI;
IF OperandSize = 32
    THEN EBP ← Pop();
    ELSE IF OperandSize = 64
        THEN RBP ← Pop(); FI;
    ELSE IF OperandSize = 16
        THEN BP ← Pop(); FI;
FI;

==>
mov esp ebp
pop ebp
```

#### call

```assembly
push eip
jmp
```

### 0x4 堆分配--小记

- **Fastbins** 存在的更具体的原因是 **避免 chunk 重复切割合并**.

  对于长度很小的 chunk 在释放后不会放到 Bins, 也不会标记为空闲, 这就避免了**合并**, 下次分配内存时首先查找 Fastbins, 这就避免了**切割**.

- **刚刚释放的内存什么时候加到 Bins ?** **这其实就与 Unsorted 有关,** 刚刚释放的内存会先放到 Unsorted 缓存, 在下一次内存分配时, 会优先于 Bins 查找, 如果能命中 Unsorted 缓冲最好, 否则就把 Unsorted 中的 chunk 统一整理到对应 Bins(Large or small bin).

- bins 中的 chunk 是按照大小排序的. **FIFO,** **small bins 是不 存在按大小排序的, 因为每一个 small bin 都是相同 size 的**. **但是对 于 large bin 是需要按照顺序插入的.** 这样可以在内存分配时很快查找到 合适内存.

  FIFO, 从头部插入节点, 尾部取节点. 这样有个特定就是更容易内存 的合并.

- Fastbins 是单向链表, 可以通过 `fastbin->fd` 遍历 Fastbins.

- 只有一个 unsorted bin, 进行内存分配查找时先在 Fastbins, small bins 中查找, 之后会在 unsorted bin 中进行查找, 并整理 unsorted bin 中所有的 chunk 到 Bins 中对应的 Bin. unsorted bin 位于 `bin[1]`.

  `unsorted_bin->fd` 指向双向环链表的头结点, `unsorted_bin->bk` 指向双向环链表的尾节点, 在头部插入新的节点.

- **top chunk 􏵋􏲻􏲢􏰜􏲲􏴼位于最高地址。**

- **Last remainder** 是另外一种特殊的 chunk,就像 top chunk 和 mmaped chunk 一样,不会 在任何 bins 中找到这种 chunk.当需要分配一个 small chunk, 但在 small bins 中找不到合适 的 chunk, 如果 last remainder chunk 的大小大于所需的 small chunk 大小,last remainder chunk 被分裂成两个 chunk, 其中一个 chunk 返回给用户, 另一个 chunk 变成新的 last remainder chuk.

  需要注意的是, 仅在请求 small chunk 才使用. 

- 最小的malloc块：

- ```
  /*
    malloc(size_t n)
    Returns a pointer to a newly allocated chunk of at least n bytes, or null
    if no space is available. Additionally, on failure, errno is
    set to ENOMEM on ANSI C systems.
  
    If n is zero, malloc returns a minumum-sized chunk. (The minimum
    size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit
    systems.)  On most systems, size_t is an unsigned type, so calls
    with negative arguments are interpreted as requests for huge amounts
    of space, which will often fail. The maximum supported value of n
    differs across systems, but is in all cases less than the maximum
    representable value of a size_t.
  */
  ```

### 0x5 ptmalloc 的响应用户内存分配要求的具体步骤

1. 获取分配区的锁, 为了防止多个线程同时访问同一个分配区, 在进行分配之前需要取得分配区域的锁. 线程先查看线程私有实例中是否已经存在一个分配区, 如果存在尝试对该分配区加锁, 如果加锁成功, 使用该分配区分配内存, 否则, 该线程搜 索分配区循环链表试图获得一个空闲（没有加锁）的分配区. 如果所有的分配区都已经加锁, 那么 ptmalloc 会开辟一个新的分配区, 把该分配区加入到全局分配区循环链表和线程的私有实例中并加锁, 然后使用该分配区进行分配操作. 开辟出来的新分配区一定为非主分配区, 因为主分配区是从父进程那里继承来的. **开辟非主分配区时会调用 mmap()创建一个 sub-heap, 并设置好 top chunk.**
2.  将用户的请求大小转换为实际需要分配的 chunk 空间大小. `具体查看 request2size 宏 (malloc.c:3332)`
3. 判断所需分配 chunk 的大小是否满足 `chunk_size` <= `max_fast `(`max_fast` 默认为 64B),  如果是的话, 则转下一步, 否则跳到第 5 步. `(malloc.c:3340)`
4. 首先尝试在 Fastbins 中查找所需大小的 chunk 分配给用户. 如果可以找到, 则分配结束. 否则转到下一步.` (malloc.c:3340)`
5. 判断所需大小是否处在 small bins 中, 即判断 `chunk_size` < 512B 是否成立. 如果 chunk 大小处在 small bins 中, 则转下一步, 否则转到第 7 步. `(malloc.c:3377)`
6. 根据所需分配的 chunk的大小, 找到具体所在的某个 small bin, 从该 Bin 的尾部摘取一个恰好满足大小的 chunk. 若成功, 则分配结束, 否则, 转到 8. `(malloc.c:3377)`
7. 到了这一步, 说明需要分配的是一块大的内存, 于是, ptmalloc 首先会遍历 Fastbins 中的 chunk, 将相邻的空闲 chunk 进行合并,  并链接到 unsorted bin 中. 对于 Fastbins 的合并是由 `malloc_consolidate` 做处理. `(malloc.c:3421)`
8. 遍历 unsorted bin 中的 chunk, 如果请求的 chunk 是一个 small chunk, 且 unsorted bin 只有一个 chunk, 并且这个 chunk 在上次分配时被使用过(也就是 **last_remainder**), 并且 chunk 的大小大于 (分配的大小 + MINSIZE), 这种情况下就直接将该 chunk 进行切割, 分配结束, 否则继续遍历, 如果发现一个 unsorted bin 的 size 恰好等于需要分配的 size, 命中缓存, 分配结束, 否则将根据 chunk 的空间大小将其放入对应的 small bins 或是 large bins 中, 遍历完成后, 转入下一步.` (malloc.c:3442)`
9. 到了这一步说明需要分配的是一块大的内存, 并且 Fastbins 和 unsorted bin 中所有的 chunk 都清除干净 了. 从large bins 中按照 “smallest-first, best-fit”(最小&合适, 也就是说大于或等于所需 size 的最小 chunk) 原则, 找一个合适的 chunk, 从中划分一块合适大小的 chunk 进行切割, 并将剩下的部分放到 unsorted bin, 若操作成功, 则分配结束, 否则转到下一步. `(malloc.c:3576)`
10. 到了这一步说明在对应的 bin 上没有找到合适的大小, 无论是 small bin 还是 large bin, 对于 small bin, 如果没有对应大小的 small bin, 只能 idx+1. 对于 large bin,在上一步的 large bin 并不一定能找到合适的 chunk 进行切割, 因为 large bins 间隔是很大的, 假如当前的 idx 的 large bin 只有一个 chunk, 但是所需 size 大于该 chunk, 这就导致找不到合适的, 只能继续 idx+1, 最后都需要根据 bitmap 找到之后第一个非空闲的 bin.  在这两种情况下找到的 bin 中的 chunk 一定可以进行切割或者全部分配(剩余的 size < MINSIZE)` (malloc.c:3649)`
11. 如果仍然都没有找到合适的 chunk, 那么就需要操作 top chunk 来进行分配了. 判断 top chunk 大小是否满足所需 chunk 的大小, 如果是, 则从 top chunk 中分出一块来. 否则转到下一步. `(malloc.c:3749)`
12. 到了这一步, 说明 top chunk 也不能满足分配要求, 所以, 于是就有了两个选择: 如果是主分配区, 调用 sbrk(), 增加 top chunk 大小；如果是非主分配区, 调用 mmap 来分配一个新的 sub-heap, 增加 top chunk 大小；或者使用 mmap()来直接分配. 在这里, 需要依靠 chunk 的大小来决定到底使用哪种方法. 判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值, 如果是的话, 则转下一步, 调用 mmap 分配,  否则跳到第 13 步, 增加 top chunk 的大小. `(malloc.c:3800)`
13. 使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间. 然后将内存指针返回给用户.
14. 判断是否为第一次调用 malloc, 若是主分配区, 则需要进行一次初始化工作, 分配一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap. 若已经初始化过了, 主分配区则调用 sbrk()增加 heap 空间, 分主分配区则在 top chunk 中切割出一个 chunk, 使之满足分配需求, 并将内存指针返回给用户.

### 0x6 free()过程（32位）

```
1) free()函数同样首先需要获取分配区的锁, 来保证线程安全.

2) 判断传入的指针是否为 0, 如果为 0, 则什么都不做, 直接 return.否则转下一步.

3) 判断 chunk 的大小和所处的位置, 若 chunk_size <= max_fast, 并且 chunk 并不位于 heap 的顶部, 也就是说并不与 Top chunk 相邻, 则转到下一步, 否则跳到第 5 步.（因为与 top chunk 相邻的 chunk(fastbin) ,会与 top chunk 进行合并, 所以这里不仅需要判断大小, 还需要判断相邻情况）

4) 将 chunk 放到 Fastbins 中, chunk 放入到 Fastbins 中时, 并不修改该 chunk 使用状 态位 P.也不与相邻的 chunk 进行合并.只是放进去, 如此而已.这一步做完之后 释放便结束了, 程序从 free()函数中返回.

5) 判断所需释放的 chunk 是否为 mmaped chunk, 如果是, 则调用 munmap()释放 mmaped chunk, 解除内存空间映射, 该该空间不再有效.如果开启了 mmap 分配 阈值的动态调整机制, 并且当前回收的 chunk 大小大于 mmap 分配阈值, 将 mmap 分配阈值设置为该 chunk 的大小, 将 mmap 收缩阈值设定为 mmap 分配阈值的 2 倍, 释放完成, 否则跳到下一步.

6) 判断前一个 chunk 是否处在使用中, 如果前一个块也是空闲块, 则合并.并转下一步.

7) 判断当前释放 chunk 的下一个块是否为 top chunk, 如果是, 则转第 9 步, 否则转 下一步.

8) 判断下一个 chunk 是否处在使用中, 如果下一个 chunk 也是空闲的, 则合并, 并将合并后的 chunk 放到 unsorted bin 中.注意, 这里在合并的过程中, 要更新 chunk 的大小, 以反映合并后的 chunk 的大小.并转到第 10 步.

9) 如果执行到这一步, 说明释放了一个与 top chunk 相邻的 chunk.则无论它有多大,  都将它与 top chunk 合并, 并更新 top chunk 的大小等信息.转下一步. (malloc.c:3950)

10) 判断合并后的 chunk 的大小是否大于 FASTBIN_CONSOLIDATION_THRESHOLD（默认 64KB）, 如果是的话, 则会触发进行 Fastbins 的合并操作(malloc_consolidate), Fastbins 中的 chunk 将被遍历, 并与相邻的空闲 chunk 进行合并, 合并后的 chunk 会被放到 unsorted bin 中. Fastbins 将变为空, 操作完成之后转下一步.

11) 判断 top chunk 的大小是否大于 mmap 收缩阈值（默认为 128KB）, 如果是的话, 对于主分配区, 则会试图归还 top chunk 中的一部分给操作系统.但是最先分配的 128KB 空间是不会归还的, ptmalloc 会一直管理这部分内存, 用于响应用户的分配 请求；如果为非主分配区, 会进行 sub-heap 收缩, 将 top chunk 的一部分返回给操 作系统, 如果 top chunk 为整个 sub-heap, 会把整个 sub-heap 还回给操作系统.做 完这一步之后, 释放结束, 从 free() 函数退出.可以看出, 收缩堆的条件是当前 free 的 chunk 大小加上前后能合并 chunk 的大小大于 64k, 并且要 top chunk 的大 小要达到 mmap 收缩阈值, 才有可能收缩堆.
```

### 0x7 Unsorted attack

> 自[ctf-wiki](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unsorted_bin_attack-zh/)的笔记

#### 7x1 基本来源

1. 当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。
2. 释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。
3. 当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。

#### 7x2 原理

[malloc.c](https://code.woboq.org/userspace/glibc/malloc/malloc.c.html)源码：

```c
 /* remove from unsorted list */
          if (__glibc_unlikely (bck->fd != victim))
            malloc_printerr ("malloc(): corrupted unsorted chunks 3");
          unsorted_chunks (av)->bk = bck;
          bck->fd = unsorted_chunks (av);
```

#### 7x3 根据shellphish 的 how2heap 仓库中的 [unsorted_bin_attack.c](https://github.com/shellphish/how2heap/blob/master/unsorted_bin_attack.c) 描述过程。

1. 先申请一个符合大小的chunk.

2. free这个chunk

3. 需要一个**UAF**将bk指针指向**以目标位置为fd指针的伪chunk**。

4. malloc一个与第一步那个chunk大小相近的chunk。

5. 第4步会使程序进入 

   `unsorted_chunks (av)->bk = bck;`
   `bck->fd = unsorted_chunks (av);`

6. 这样会把目标地址覆盖成`unsorted_chunks (av)`，即一个很大的值。

#### 7x4 思考

这个漏洞自身利用感觉很鸡肋（太菜了，没做过类似的题）

但是，可以配合global_max_fast来使用。

### 0x8 Fastbin Attack

> 来自[ctf-wiki](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/)的笔记

#### 8x1 前提

- 存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞
- 漏洞发生于 fastbin 类型的 chunk 中

#### 8x2 原理

fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空。





